人工智能第八周作业：
<!--
（1）第三章习题3-6、3-7
（2）按宽度优先搜索，写出下图Open和Close表中的变化
（3）总结PPT-Talk5第27页的通用图算法，介绍其流程
（4）按深度优先和宽度优先搜索分别画出求解8数码的图
手写拍照第九周上课前提交至邮箱605432130@qq.com
-->
- （1）第三章习题3-6、3-7
- （2）按宽度优先搜索，写出下图Open和Close表中的变化
	  ![](Assets/491A61575957B86A80F68F5F0831EEA0.jpg)
- （3）总结PPT-Talk5第27页的通用图算法，介绍其流程
	  一个通用的图搜索算法
	- 1)生成一个仅包含开始节点n0的搜索树Tr。把n0放 在一个称为OPEN（未扩展节点表）的有序列表中 。
	- 2)生成一个初始值为空的列表CLOSED（已扩展节点 表）。
	- 3)如果OPEN为空，则失败并退出。
	- 4)选出OPEN中的第一个节点，并将它从OPEN中移出 ，放入CLOSED中。称该节点为n。
	- 5)如果n是目标节点，顺着Tr中的弧从n回溯 到n0找到一条路径，获得解决方案，则成功 退出。
	- 6)扩展节点n，生成n的后继节点集M。通过在 Tr中建立从n到M中每个成员的弧生成n的后 继。
	- 7)按照任意的模式或启发式方式对列表OPEN 重新排序。
	- 8)返回步骤3。
- （4）按深度优先和宽度优先搜索分别画出求解8数码的图
手写拍照第九周上课前提交至邮箱[605432130@qq.com](mailto:605432130@qq.com)

---

# (1)
## 3-6
![3-6](Assets/0FFE08DC7C4D5CED55EB32209925E2CE.png)

## 3-7
```cpp
#include <iostream>
#include <vector>
#include <utility>
#include <set>

#define N_MOV 4
#define MAX_STEP 20

using namespace std;

typedef vector<long long> ll_vec;
typedef pair<long long, long long> PLL;
typedef pair<short, long long> stepT;
typedef vector<stepT> proceT;

const PLL Movs[N_MOV] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

inline bool isIdxValid(const vector<ll_vec> &Board, const PLL &idx)
{
    return (idx.first >= 0) && (static_cast<size_t>(idx.first) < (Board.size())) && (idx.second >= 0) && (static_cast<size_t>(idx.second) < ((Board[idx.first].size())));
}

inline vector<proceT> solve(vector<ll_vec> &Board_ini, const vector<ll_vec> &Board_tar, vector<PLL> &PosMovs, const long long maxStep = 0)
{
    vector<proceT> sols;
    auto n = Board_ini.size();
    if ((!(Board_ini.empty())) && (n == (Board_tar.size())) && (!(PosMovs.empty())) && (maxStep >= 0))
    {
        bool flag = true;
        if (Board_ini == Board_tar)
            sols.emplace_back();
        for (vector<ll_vec>::const_iterator it1 = (Board_ini.begin()), it2 = (Board_tar.begin()); it1 < Board_ini.end(); ++it1, ++it2)
            if (it1->size() != (it2->size()))
            {
                flag = false;
                break;
            }
        if (flag)
        {
            proceT procs = {{-1, 0}};
            set<vector<ll_vec>> vis = {Board_ini};
            while (!(procs.empty()))
            {
                auto j = (procs.back()).first + 1;
                for (auto i = (procs.back()).second; flag && (static_cast<size_t>(i) < (PosMovs.size())); ++i, j = 0)
                    for (; flag && (j < N_MOV); ++j)
                        if (isIdxValid(Board_ini, PosMovs[i]) && isIdxValid(Board_ini, {PosMovs[i].first + (Movs[j].first), PosMovs[i].second + (Movs[j].second)}))
                        {
                            swap(Board_ini[PosMovs[i].first][PosMovs[i].second], Board_ini[PosMovs[i].first + (Movs[j].first)][PosMovs[i].second + (Movs[j].second)]), PosMovs[i].first += (Movs[j].first), PosMovs[i].second += (Movs[j].second);
                            if ((vis.find(Board_ini) == vis.end()))
                            {
                                auto temp = procs.back();
                                (procs.back()).first = static_cast<short>(j), (procs.back()).second = i;
                                if (Board_ini == Board_tar)
                                    sols.push_back(procs);
                                else
                                {
                                    if ((!maxStep) || (procs.size() < static_cast<size_t>(maxStep)))
                                        vis.insert(Board_ini), flag = false;
                                }
                                if (flag)
                                    procs.back() = temp;
                            }
                            if (flag)
                                swap(Board_ini[PosMovs[i].first][PosMovs[i].second], Board_ini[PosMovs[i].first - (Movs[j].first)][PosMovs[i].second - (Movs[j].second)]), PosMovs[i].first -= (Movs[j].first), PosMovs[i].second -= (Movs[j].second);
                            else
                            {
                                procs.emplace_back(-1, 0);
                                break;
                            }
                        }
                if (flag)
                {
                    procs.pop_back(), vis.erase(Board_ini);
                    if (!(procs.empty()))
                        swap(Board_ini[PosMovs[(procs.back()).second].first][PosMovs[(procs.back()).second].second], Board_ini[PosMovs[(procs.back()).second].first - (Movs[(procs.back()).first].first)][PosMovs[(procs.back()).second].second - (Movs[(procs.back()).first].second)]), PosMovs[(procs.back()).second].first -= (Movs[(procs.back()).first].first), PosMovs[(procs.back()).second].second -= (Movs[(procs.back()).first].second);
                }
                else
                    flag = true;
            }
        }
    }
    return sols;
}

int main()
{
    long long m = 0, n = 0;
    cin >> m >> n;
    vector<PLL> PosMovs;
    vector<ll_vec> Board_ini(m, ll_vec(n)), Board_tar(m, ll_vec(n));
    for (auto it1 = (Board_ini.begin()); it1 < (Board_ini.end()); ++it1)
        for (auto it2 = (it1->begin()); it2 < (it1->end()); ++it2)
            if ((cin >> (*it2)) && (!(*it2)))
                PosMovs.emplace_back(it1 - Board_ini.begin(), it2 - (it1->begin()));
    for (auto it1 = (Board_tar.begin()); it1 < (Board_tar.end()); ++it1)
        for (auto it2 = (it1->begin()); it2 < (it1->end()); ++it2)
            cin >> (*it2);
    auto Sols = solve(Board_ini, Board_tar, PosMovs, MAX_STEP);
    cout << "Solution count: " << Sols.size() << endl
         << endl;
    for (auto it1 = (Sols.begin()); it1 < Sols.end(); ++it1)
    {
        cout << "Solution " << it1 - (Sols.begin()) << endl;
        vector<PLL> Pos = PosMovs;
        vector<ll_vec> Board = Board_ini;
        for (auto it2 = (it1->begin()); it2 < (it1->end()); ++it2)
        {
            cout << "Step: " << it2 - (it1->begin()) << endl;
            swap(Board[Pos[it2->second].first][Pos[it2->second].second], Board[Pos[it2->second].first + (Movs[it2->first].first)][Pos[it2->second].second + (Movs[it2->first].second)]), Pos[it2->second].first += (Movs[it2->first].first), Pos[it2->second].second += (Movs[it2->first].second);
            for (auto it3 = (Board.begin()); it3 < (Board.end()); ++it3)
            {
                for (auto it4 = (it3->begin()); it4 < (it3->end()); ++it4)
                    cout << (*it4) << ' ';
                cout << endl;
            }
        }
    }
    return 0;
}

```

# (2)
1. 
	- Open: \[A\]
	- Close: \[\]
2. 
	- Open: \[B, F\]
	- Close: \[A\]
3. 
	- Open: \[F, E, C, G\]
	- Close: \[A, B\]
4. 
	- Open: \[E, C, G, H, I\]
	- Close: \[A, B, F\]

# (3)
1. Initialize a search tree (`Tr`) with only the start node (`n0`). Place `n0` in an ordered list called `OPEN` (unexpanded nodes).
2. Initialize an empty list called `CLOSED` (expanded nodes).
3. If `OPEN` is empty, the search fails and exits.
4. Select the first node from `OPEN`, remove it, and add it to `CLOSED`. Call this node `'n'`.
5. If `'n'` is the goal node, trace back through `Tr` from `'n'` to `n0` to find a path, obtain the solution, and exit successfully.
6. Expand node `'n'` to generate its successor set `'M'`. Add arcs from `'n'` to each member of `'M'` in `Tr`.
7. Reorder the `OPEN` list according to any pattern or heuristic.
8. Return to step 3.

# (4)
What specific problem?
